# Tech Stack

Single reference for every concrete technology choice across the monorepo. Locked in before implementation begins.

---

## Overview

| Package | Primary tech |
|---|---|
| `@heydata/web` | Next.js 15, React 19, Tailwind CSS |
| `@heydata/semantic` | TypeScript, Zod, YAML definitions |
| `@heydata/core` | TypeScript, Anthropic SDK, Zod |
| `@heydata/bridge` | TypeScript, node-postgres (`pg`) |
| `@heydata/renderer` | React, Recharts |
| `@heydata/shared` | TypeScript, Zod |
| Monorepo | pnpm workspaces, Turborepo, TypeScript |

---

## Monorepo Tooling

- **Package manager:** pnpm workspaces — efficient installs, strict dependency isolation between packages
- **Build orchestration:** Turborepo — parallel task execution, incremental builds with caching
- **Language:** TypeScript throughout (strict mode) — single language across all layers, shared types work without transpilation ceremony
- **Build output:** `tsup` for library packages (`shared`, `semantic`, `bridge`, `core`, `renderer`); Next.js handles its own bundling for `web`
- **Testing:** Vitest — fast, native TypeScript support, compatible with the pnpm + Turbo setup
- **Linting:** ESLint + `@typescript-eslint`
- **Formatting:** Prettier
- **Shared configs location:** `configs/` — holds shared `tsconfig.base.json`, `eslint.base.js`, `prettier.config.js`

---

## Per-Layer Tech Stack

### `@heydata/web` — Next.js 15 (App Router)

**Why Next.js:**
- App Router handles streaming responses natively — critical for LLM output
- Server Actions and API Routes allow keeping LLM calls server-side (no key exposure)
- Full-stack in a single package; no separate backend service needed at v1

**Stack:**
- Next.js 15 (App Router, React Server Components)
- React 19
- Tailwind CSS — utility-first, no CSS build complexity
- No external state management library — React Context + `useReducer` sufficient for conversation state at v1

**Key dependencies:** `next`, `react`, `react-dom`, `tailwindcss`

---

### `@heydata/semantic` — Pure TypeScript + Zod + YAML

**Why this approach:**
- Metric definitions are human-authored data files, not code — YAML is readable by analytics engineers and business users
- Zod provides runtime validation so invalid definitions are caught at load time, not at query time
- No framework needed; this is a pure data parsing and lookup library

**Stack:**
- TypeScript (pure library, no runtime framework)
- Zod — schema definition and runtime validation for metric/dimension definitions
- `js-yaml` — parse YAML definition files into TypeScript objects

**Key dependencies:** `zod`, `js-yaml`

---

### `@heydata/core` — Anthropic SDK (raw)

**Why raw SDK over a framework:**
- Avoids abstraction layers that obscure token usage, latency, and error details — all critical for observability
- Each agent is a focused function with a typed input/output contract; a framework adds little here
- Direct control over system prompts, tool definitions, and retry logic per agent

**Stack:**
- TypeScript
- `@anthropic-ai/sdk` — direct Claude API access with streaming support
- Zod — validate structured outputs from each agent (LLM outputs are untrusted text; Zod parses them into typed objects)

**Model strategy (open decision):** Start with `claude-sonnet-4-6` for all agents. Tune per-agent model selection based on observed cost/quality tradeoffs after initial testing.

**Key dependencies:** `@anthropic-ai/sdk`, `zod`

---

### `@heydata/bridge` — node-postgres

**Why node-postgres:**
- PostgreSQL-only at v1; `pg` is the canonical, battle-tested Node.js driver
- No ORM — the bridge executes raw SQL (generated by the LLM), not model queries
- Connection pooling via `pg-pool` (bundled with `pg`)

**Security guards implemented in code (not at DB level):**
- Blocklist of forbidden SQL keywords (DROP, DELETE, INSERT, UPDATE, TRUNCATE, ALTER)
- Row limit enforcement (`LIMIT` injection if not present)
- Query timeout (configurable, default 30s)

**Key dependencies:** `pg`, `@types/pg`

---

### `@heydata/renderer` — Recharts

**Why Recharts:**
- React-native (JSX components, not canvas/SVG imperatively) — fits naturally into the Next.js component tree
- Declarative API aligns with the abstract viz spec approach: spec → component props
- Good defaults, accessible, actively maintained

**Supported chart types at v1:**
Line, Bar, Area, Scatter, composed (dual-axis), KPI card (custom), data table (custom with TanStack Table)

**Additional dependency:** `@tanstack/react-table` for the data table view

**Key dependencies:** `recharts`, `@tanstack/react-table`

---

### `@heydata/shared` — TypeScript + Zod

**Why Zod here too:**
- Shared types serve two purposes: TypeScript compile-time checking AND runtime validation of LLM outputs and API boundaries
- Zod schemas can be inferred as TypeScript types (`z.infer<typeof schema>`) — single source of truth for both

**Key types defined here:**
- `IntentObject` — output of Intent Resolver Agent
- `ValidationResult` — SQL Validator and Data Validator outputs
- `InsightAnnotation` — Data Analyzer output
- `VisualizationSpec` — Viz Planner output
- `ResultSet` — structured query results from bridge
- `MetricDefinition`, `DimensionDefinition`, `EntityRelationship` — semantic layer types
- `AgentTrace` — per-agent observability payload
- Error types and codes

**Key dependencies:** `zod`

---

## Testing Strategy

- **Unit tests:** Vitest for all packages — each agent in `core` is independently testable with mock inputs/outputs
- **Integration tests:** Test the full pipeline in `core` with mocked bridge and Anthropic SDK responses
- **E2E:** Playwright for the `web` package (deferred to later)

---

## Open Decisions

The following affect tech stack as they get resolved (see `docs/open-questions.md`):

- **Multi-tenant:** If needed, adds per-tenant connection pooling and semantic layer namespacing to `bridge` and `semantic`
- **Async/scheduled queries:** If needed, adds a job queue (e.g., BullMQ + Redis) to `bridge`
- **Multi-warehouse:** If needed, adds dialect adapters per warehouse to `bridge`
- **Per-agent model selection:** Resolved through experimentation after v1 baseline is established
